{"version":3,"sources":["map-dashboard.component.ts"],"names":["core_1","require","L","icon_utils_1","leaflet_geosearch_1","operators_1","base_component_1","utils_1","rxjs_1","MapDashboardComponent","_super","mapDashBoardService","categoryService","layerTreeNodeService","treeNodeService","popupService","appMessageService","confirmationService","router","elem","_this","call","this","entities","showButtons","favChecked","favAttrs","colors","low","moderate","high","very_high","extreme","intervalRefreshMilliseconds","entityAttr","latCenter","longCenter","markerClusterGroup","animate","showCoverageOnHover","layerGroups","removedLayers","filters","unselectedLayers","currentModels","markersByModelAndId","firstFetch","minLat","Number","POSITIVE_INFINITY","minLon","maxLat","NEGATIVE_INFINITY","maxLon","defaultZoom","firstLoad","tooltipMaxChars","filteredAttrs","__extends","prototype","ngAfterViewInit","loadAllEntitiesForLayers","loadMap","loadSearchBar","visualizeEntities","ngOnDestroy","clearInterval","interval","onNodeSelect","event","i","indexOf","node","data","splice","addLayer","closeTooltipsIfNeeded","setFilters","onNodeUnselect","push","removeLayer","onEventFilters","storeFilterAttrs","startInterval","updateEntities","onFavChange","getLayers","forEach","l","checked","getTooltip","openTooltip","closeTooltip","onLayerConditionClick","layerPanel","overlayVisible","hide","stopPropagation","layerConditionsPanel","toggle","onLayerClick","onCenterClick","map","flyTo","center","zoom","minZoom","maxBounds","latLngBounds","latLng","maxBoundsViscosity","doubleClickZoom","setTileLayer","setZoomStartEvent","setAnimationEndEvent","tileLayer","attribution","maxNativeZoom","maxZoom","addTo","on","nativeElement","querySelectorAll","e","style","display","searchControl","GeoSearchControl","provider","OpenStreetMapProvider","autoClose","addControl","adjustView","lat","lon","isNaN","setView","loadMarkerCluster","Object","values","lg","addLayers","layersBeforeFilter","removeLayersForFilters","f","entity","attribute","layersToRemove","layer","selected","type","applyFilter","removeLayers","controlName","condition","Utils","mathItUp","value","JSON","stringify","includes","getAllEntitiesForLayers","pipe","takeUntil","destroy$","subscribe","res","mapCategories","loadLayerMenu","err","onLoadDataFail","categories","categoryKey","getCategoryKey","name","categoryExist","find","category","label","addCategory","IconUtils","categoryName","icon","icons","applyFiltersAfterUpdating","markersWithNewLocation","m","currentLocation","location","coordinates","setLatLng","slice","reverse","layers","getMainLayers","selectedLayers","getAllSelected","loadEntities","getEntitiesData","models","length","onLoadEntitiesSuccess","onLoadEntitiesEmpty","storeFavAttrs","processModels","setInterval","triggeredByFilter","combinedCalls","model","obs","getEntitiesForUpdating","processUpdate","combineLatest","combinedResults","updateEntity","layerGroup","addEntity","confirm","header","message","acceptLabel","rejectLabel","accept","navigate","add","severity","summary","getColor","index","color","setGeoJSONattributes","fireWeatherIndex","geoJSON","parse","storeMinMaxLocation","insertEntity","isValidCoordinates","marker","leafletIcons","setEntityParams","id","hasLocationBeenUpdated","entries","a","setTooltip","setPopup","currentLatLng","getLatLng","currentLat","currentLng","lng","newLatLng","newLat","newLng","setMarkerEvents","p","pRef","isPopupOpen","closePopup","openPopup","unbindPopup","popup","popupComponentRef","createPopupComponent","instance","clickDebug","onClickDebug","setContent","getEntityForPopup","updatedEntity","updatePopup","changeDetectorRef","detectChanges","refreshScroll","bindPopup","fromDebug","tooltipContent","getTooltipContent","setTooltipContent","bindTooltip","offset","Point","direction","permanent","opacity","favAttr","truncateTooltipContent","undefined","content","str","truncateString","filter","getEntity","onClickDebugSuccess","displayDebugHeader","displayDebugContent","displayDebug","__decorate","ViewChild","Component","selector","templateUrl","styleUrls","BaseComponent","exports"],"mappings":"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","file":"map-dashboard.component.min.js","sourcesContent":["import { CategoryFilter } from '../models/category-filter';\nimport { ConditionFilter } from '../models/condition-filter';\nimport { Component, AfterViewInit, ElementRef, OnDestroy, ComponentRef, ViewChild } from '@angular/core';\nimport { MenuItem } from 'primeng/api/menuitem';\nimport { TreeNode } from 'primeng/api/treenode';\nimport * as L from 'leaflet';\nimport 'leaflet.markercluster';\nimport 'leaflet/dist/images/marker-shadow.png';\nimport 'leaflet/dist/images/marker-icon.png';\nimport 'leaflet/dist/images/marker-icon-2x.png';\nimport { IconUtils } from '../../../shared/misc/icon-utils';\nimport { GeoSearchControl, OpenStreetMapProvider } from 'leaflet-geosearch';\nimport { MapDashboardService } from '../services/map-dashboard.service';\nimport { PopupService } from '../services/popup-service';\nimport { Entity } from 'src/app/shared/models/entity';\nimport { ModelDto } from 'src/app/shared/models/model-dto';\nimport { takeUntil } from 'rxjs/operators';\nimport { BaseComponent } from 'src/app/shared/misc/base.component';\nimport { Utils } from '../../../shared/misc/utils';\nimport { AppMessageService } from 'src/app/shared/services/app-message-service';\nimport { ConfirmationService } from 'primeng/api';\nimport { Router } from '@angular/router';\nimport { EntityFilter } from '../models/category-filter';\nimport { PopupComponent } from 'src/app/shared/templates/popup/popup.component';\nimport { OverlayPanel } from 'primeng/overlaypanel/public_api';\nimport { LayerTreeNodeService } from '../services/layer-tree-node.service';\nimport { CategoryService } from '../services/category-service';\nimport { TreeNodeService } from 'src/app/shared/services/tree-node.service';\nimport { Observable, combineLatest } from 'rxjs';\n\n@Component({\n    selector: 'app-map-dashboard',\n    templateUrl: './map-dashboard.component.html',\n    styleUrls: ['./map-dashboard.component.scss'],\n})\nexport class MapDashboardComponent extends BaseComponent implements AfterViewInit, OnDestroy {\n\n    public categories: CategoryFilter[];\n    public entities: EntityFilter[] = [];\n    public menuItems: MenuItem[];\n    public layers: TreeNode[];\n    public selectedLayers: TreeNode[];\n    public showButtons: boolean = false;\n    public favChecked: boolean = true;\n    public favAttrs: { entity: string, favAttr: string }[] = [];\n    public displayDebug: boolean;\n    public displayDebugHeader: string;\n    public displayDebugContent: Entity;\n\n    private colors: any = {low:\"#28a746\",moderate:\"#5894f4\",high:\"#ffc107\",very_high:\"#ec7628\",extreme:\"#dc3546\"};\n    private intervalRefreshMilliseconds: number = 60000;\n    private entityAttr: string = 'data';\n    private map: L.Map;\n    private latCenter: number = -34.0736;\n    private longCenter: number = -64.7647;\n    private markerClusterGroup: L.MarkerClusterGroup = L.markerClusterGroup({ animate: true, showCoverageOnHover: false });\n    private layerGroups: { [key: string]: L.LayerGroup } = {};\n    private layersBeforeFilter: L.Layer[];\n    private removedLayers: L.Layer[] = [];\n    private filters: ConditionFilter[] = [];\n    private unselectedLayers: any[] = [];\n    public currentModels: ModelDto[] = [];\n    private markersByModelAndId: any = {};\n    private firstFetch: boolean = true;\n    private interval: any;\n    private minLat: number = Number.POSITIVE_INFINITY;\n    private minLon: number = Number.POSITIVE_INFINITY;\n    private maxLat: number = Number.NEGATIVE_INFINITY;\n    private maxLon: number = Number.NEGATIVE_INFINITY;\n    private defaultZoom: number = 10;\n    private firstLoad: boolean = true;\n    private tooltipMaxChars: number = 25;\n    private filteredAttrs: any = {};\n\n    @ViewChild('layerConditionsPanel') private layerConditionsPanel: OverlayPanel;\n    @ViewChild('layerPanel') private layerPanel: OverlayPanel;\n\n\n    constructor(\n        private mapDashBoardService: MapDashboardService,\n        private categoryService: CategoryService,\n        private layerTreeNodeService: LayerTreeNodeService,\n        private treeNodeService: TreeNodeService,\n        private popupService: PopupService,\n        private appMessageService: AppMessageService,\n        private confirmationService: ConfirmationService,\n        private router: Router,\n        private elem: ElementRef,\n    ) {\n        super();\n    }\n\n    public ngAfterViewInit(): void {\n        this.loadAllEntitiesForLayers();\n        this.loadMap();\n        this.loadSearchBar();\n        this.visualizeEntities();\n    }\n\n    public ngOnDestroy(): void {\n        clearInterval(this.interval);\n    }\n\n    /*****************************************************************************\n     Event functions\n    *****************************************************************************/\n\n    public onNodeSelect(event: any): void {\n        const i: number = this.unselectedLayers.indexOf(event.node.data);\n        this.unselectedLayers.splice(i, 1);\n        this.markerClusterGroup.addLayer(this.layerGroups[event.node.data]);\n        this.closeTooltipsIfNeeded();\n        this.setFilters();\n    }\n\n    public onNodeUnselect(event: any): void {\n        this.unselectedLayers.push(event.node.data);\n        this.markerClusterGroup.removeLayer(this.layerGroups[event.node.data]);\n    }\n\n    public onEventFilters(event: ConditionFilter[]): void {\n        this.filters = event;\n        this.storeFilterAttrs(event);\n        clearInterval(this.interval);\n        this.startInterval();\n        this.updateEntities(true);\n    }\n\n    public onFavChange(event: any): void {\n        this.markerClusterGroup.getLayers().forEach(l => {\n            event.checked && l.getTooltip() ? this.openTooltip(l as L.Marker) : l.closeTooltip();\n        });\n    }\n\n    public onLayerConditionClick(event: any): void {\n        if (this.layerPanel.overlayVisible) { this.layerPanel.hide(); }\n        event.stopPropagation();\n        this.layerConditionsPanel.toggle(event);\n    }\n\n    public onLayerClick(event: any): void {\n        if (this.layerConditionsPanel.overlayVisible) { this.layerConditionsPanel.hide(); }\n        event.stopPropagation();\n        this.layerPanel.toggle(event);\n    }\n\n    public onCenterClick(): void {\n        this.map.flyTo([this.latCenter, this.longCenter], this.defaultZoom);\n    }\n\n    /*****************************************************************************\n     Map loading functions\n    *****************************************************************************/\n\n    private loadMap(): void {\n        this.map = L.map('map', {\n            center: [this.latCenter, this.longCenter],\n            zoom: this.defaultZoom,\n            minZoom: 1,\n            maxBounds: L.latLngBounds(L.latLng(-90, -180), L.latLng(90, 180)),\n            maxBoundsViscosity: 0.5,\n            doubleClickZoom: true,\n        });\n\n        this.setTileLayer();\n        this.map.addLayer(this.markerClusterGroup);\n        this.setZoomStartEvent();\n        this.setAnimationEndEvent();\n    }\n    private setTileLayer(): void {\n        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n            attribution: '&copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>',\n            maxNativeZoom: 19,\n            maxZoom: 19,\n        }).addTo(this.map);\n    }\n\n    private setZoomStartEvent(): void {\n        this.map.on('zoomstart', (event) => {\n            this.markerClusterGroup.getLayers().forEach(l => {\n                if (l.getTooltip()) {\n                    const elements: NodeList = this.elem.nativeElement.querySelectorAll('.leaflet-tooltip-pane');\n                    elements.forEach((e: HTMLElement) => e.style.display = 'none');\n                }\n            });\n        });\n    }\n\n    private setAnimationEndEvent(): void {\n        this.markerClusterGroup.on('animationend', () => {\n            this.markerClusterGroup.getLayers().forEach(l => {\n                this.openTooltip(l as L.Marker);\n            });\n        });\n    }\n\n    private loadSearchBar(): void {\n        const searchControl: GeoSearchControl = new GeoSearchControl({\n            provider: new OpenStreetMapProvider(),\n            autoClose: true,\n        });\n\n        this.map.addControl(searchControl);\n    }\n\n    private adjustView(): void {\n        this.firstLoad = false;\n        if (this.minLat !== Number.POSITIVE_INFINITY && this.minLon !== Number.POSITIVE_INFINITY &&\n            this.maxLat !== Number.NEGATIVE_INFINITY && this.maxLon !== Number.NEGATIVE_INFINITY) {\n            const lat: number = (this.minLat + this.maxLat) / 2;\n            const lon: number = (this.minLon + this.maxLon) / 2;\n            if (!isNaN(lat) && !isNaN(lon)) {\n                this.map.setView([lat, lon], this.defaultZoom);\n            }\n        }\n    }\n\n    private loadMarkerCluster(): void {\n        Object.values(this.layerGroups).forEach(lg => {\n            this.markerClusterGroup.addLayer(lg);\n        });\n    }\n\n    /*****************************************************************************\n     Filter functions\n    *****************************************************************************/\n\n    private setFilters(): void {\n        this.markerClusterGroup.addLayers(this.removedLayers);\n        this.closeTooltipsIfNeeded();\n        this.removedLayers = [];\n        if (!this.layersBeforeFilter) {\n            this.layersBeforeFilter = this.markerClusterGroup.getLayers();\n        }\n        this.removeLayersForFilters();\n    }\n\n    private storeFilterAttrs(filters: ConditionFilter[]): void {\n        this.filteredAttrs = {};\n        filters.forEach(f => {\n            if (!this.filteredAttrs[f.entity]) { this.filteredAttrs[f.entity] = []; }\n            this.filteredAttrs[f.entity].push(f.attribute);\n        });\n    }\n\n    private removeLayersForFilters(): void {\n        const layersToRemove: L.Layer[] = [];\n        this.markerClusterGroup.getLayers().forEach(layer => {\n            this.filters.forEach(f => {\n                if (f.selected && layer[this.entityAttr][f.attribute] && layer[this.entityAttr].type === f.entity) {\n                    if (this.applyFilter(layer, f, this.entityAttr)) {\n                        layersToRemove.push(layer);\n                        this.removedLayers.push(layer);\n                    }\n                }\n            });\n        });\n        this.markerClusterGroup.removeLayers(layersToRemove);\n    }\n\n    private applyFilter(layer: L.Layer, f: ConditionFilter, controlName: string): boolean {\n        let shouldBeRemoved: boolean = false;\n\n        if (f.condition !== 'contains') {\n            shouldBeRemoved = !Utils.mathItUp[f.condition](Number(layer[controlName][f.attribute]), Number(f.value));\n        } else {\n            shouldBeRemoved = !JSON.stringify(layer[controlName][f.attribute]).includes(f.value);\n        }\n\n        return shouldBeRemoved;\n    }\n\n    private loadAllEntitiesForLayers(): void {\n        this.mapDashBoardService.getAllEntitiesForLayers().pipe(takeUntil(this.destroy$)).subscribe(\n            (res: EntityFilter[]) => {\n                this.entities = this.mapCategories(res);\n                this.loadLayerMenu();\n            },\n            err => {\n                this.onLoadDataFail();\n            });\n    }\n\n    private mapCategories(entities: EntityFilter[]): EntityFilter[] {\n        this.categories = [];\n\n        entities.forEach((entity) => {\n            const categoryKey: string = this.categoryService.getCategoryKey(entity.name);\n            const categoryExist: CategoryFilter = this.categories.find((category) => category.name === categoryKey);\n            entity.label = entity.name;\n            !categoryExist ? this.addCategory(categoryKey, entity) : categoryExist.entities.push(entity);\n        });\n\n        return entities;\n    }\n\n    private addCategory(categoryKey: string, entity: EntityFilter): void {\n        this.categories.push({\n            name: categoryKey,\n            label: IconUtils.categoryName[categoryKey],\n            icon: IconUtils.icons[categoryKey],\n            entities: [entity],\n        });\n    }\n\n    private applyFiltersAfterUpdating(markersWithNewLocation: L.Marker[]): void {\n        markersWithNewLocation.forEach(m => {\n            const currentLocation: number[] = m[this.entityAttr].location.coordinates;\n            m.setLatLng(currentLocation.slice().reverse() as L.LatLngExpression);\n        });\n        this.setFilters();\n        this.unselectedLayers.forEach(l => this.markerClusterGroup.removeLayer(this.layerGroups[l]));\n        this.closeTooltipsIfNeeded();\n    }\n\n    /*****************************************************************************\n     Layers functions\n    *****************************************************************************/\n\n    private loadLayerMenu(): void {\n        this.layers = this.layerTreeNodeService.getMainLayers(this.categories);\n        this.selectedLayers = this.treeNodeService.getAllSelected(this.layers);\n    }\n\n    /*****************************************************************************\n     Data loading functions\n    *****************************************************************************/\n\n    private visualizeEntities(): void {\n        this.loadEntities();\n\n    }\n\n    private loadEntities(): void {\n        this.mapDashBoardService.getEntitiesData(!this.firstLoad).pipe(takeUntil(this.destroy$)).subscribe(\n            (models: ModelDto[]) => {\n                if (models.length > 0) {\n                    this.showButtons = true;\n                    this.onLoadEntitiesSuccess(models);\n                } else {\n                    this.showButtons = false;\n                    this.onLoadEntitiesEmpty();\n                }\n            },\n            err => {\n                this.onLoadDataFail();\n            });\n    }\n\n    private onLoadEntitiesSuccess(models: ModelDto[]): void {\n        this.currentModels = models;\n        this.storeFavAttrs(models);\n        this.processModels(models);\n        this.adjustView();\n        this.loadMarkerCluster();\n        this.setFilters();\n        this.startInterval();\n    }\n\n    private startInterval(): void {\n        this.interval = setInterval(() => {\n            this.updateEntities();\n        }, this.intervalRefreshMilliseconds);\n    }\n\n    private updateEntities(triggeredByFilter?: boolean): void {\n        const combinedCalls: Observable<any>[] = [];\n        this.currentModels.forEach((model, i) => {\n            let obs: Observable<Entity[]>;\n            obs = this.mapDashBoardService.getEntitiesForUpdating(model, this.filteredAttrs[model.type], !triggeredByFilter);\n            combinedCalls.push(obs);\n        });\n        this.processUpdate(combinedCalls);\n    }\n\n    private processUpdate(combinedCalls: Observable<any>[]): void {\n        const markersWithNewLocation: L.Marker[] = [];\n        combineLatest(combinedCalls).pipe(takeUntil(this.destroy$)).subscribe(\n            (combinedResults) => {\n                combinedResults.forEach((entities: Entity[], i: number) => {\n                    const model: ModelDto = this.currentModels[i];\n                    entities.forEach(e => this.updateEntity(e, i, model, markersWithNewLocation));\n                });\n                this.applyFiltersAfterUpdating(markersWithNewLocation);\n            },\n            err => {\n                this.onLoadDataFail();\n            },\n        );\n    }\n\n    private processModels(models: ModelDto[]): void {\n        models.forEach((model, i) => {\n            const categoryKey: string = this.categoryService.getCategoryKey(model.type);\n            this.markersByModelAndId[i] = {};\n            this.layerGroups[model.type] = this.layerGroups[model.type] || L.layerGroup();\n            this.layerGroups[categoryKey] = this.layerGroups[categoryKey] || L.layerGroup();\n            model.data.forEach(entity => {this.addEntity(model, entity, categoryKey, i)});\n            this.layerGroups[categoryKey].addLayer(this.layerGroups[model.type]);\n        });\n    }\n\n    private onLoadEntitiesEmpty(): void {\n        if (this.firstFetch) {\n            this.firstFetch = false;\n            this.confirmationService.confirm({\n                icon: 'pi pi-info',\n                header: 'There is no configuration yet',\n                message: 'Do you want to configure the dashboard?',\n                acceptLabel: 'Configure',\n                rejectLabel: 'Cancel',\n                accept: (): void => {\n                    this.router.navigate(['/configuration']);\n                },\n            });\n        }\n    }\n\n    private onLoadDataFail(): void {\n        this.appMessageService.add({ severity: 'error', summary: 'Something went wrong getting data' });\n    }\n\n    /*****************************************************************************\n     Entity functions\n    *****************************************************************************/\n\n    private getColor(index: number): string{\n        var color: string;\n        if(index < 5){\n            color = this.colors.low;\n        }else if(index >= 5 && index < 14){\n            color = this.colors.moderate;\n        }else if(index >= 14 && index < 21){\n            color = this.colors.high;\n        }else if(index >= 21 && index < 33){\n            color = this.colors.very_high;\n        }else if(index >= 33){\n            color = this.colors.extreme;\n        }\n\n        return color;\n    }\n    private setGeoJSONattributes(model: ModelDto, entity: Entity): string{\n        var color: string;\n        color = this.getColor(entity.fireWeatherIndex);\n        const geoJSON = '{   \"fillColor\": \"'+ color +'\",' +\n                            '\"weight\": 2,'+\n                            '\"opacity\": 1,' +\n                            '\"color\": \"'+ color +'\",' +  //Outline color\n                            '\"fillOpacity\": 0.7' +\n                        '}';\n        return geoJSON;\n    }\n    private addEntity(model: ModelDto, entity: Entity, categoryKey: string, i: number): void {\n        if(entity.location && entity.location.type===\"Polygon\"){\n            const geoJSON = this.setGeoJSONattributes(model, entity);\n            L.geoJSON(entity.location, {style: JSON.parse(geoJSON)}).addTo(this.layerGroups[model.type])\n            this.storeMinMaxLocation(entity.location.coordinates[0][0][1], entity.location.coordinates[0][0][0])\n            this.insertEntity(model, entity, categoryKey, i);\n        } else{\n            if (this.isValidCoordinates(entity)) {\n                this.storeMinMaxLocation(entity.location.coordinates[1], entity.location.coordinates[0]);\n                this.insertEntity(model, entity, categoryKey, i);\n            }\n        }\n\n    }\n\n    private isValidCoordinates(entity: Entity): boolean {\n        return entity.location && entity.location.coordinates &&\n            entity.location.coordinates[0] && entity.location.coordinates[1] &&\n            !isNaN(entity.location.coordinates[0]) && !isNaN(entity.location.coordinates[1]);\n    }\n\n    private insertEntity(model: ModelDto, entity: Entity, categoryKey: string, i: number): void {\n       var marker: L.Marker;\n        if(entity.location.type===\"Point\"){\n            marker = L.marker(\n                entity.location.coordinates.slice().reverse() as L.LatLngExpression,\n                { icon: IconUtils.leafletIcons[categoryKey] },\n            );\n        }else if(entity.location.type===\"Polygon\"){\n            marker= L.marker(\n                entity.location.coordinates[0][0].slice().reverse() as L.LatLngExpression,\n                { icon: IconUtils.leafletIcons[categoryKey] },\n            );\n        }\n        \n        this.setEntityParams(marker, entity, model, i);\n        \n    }\n\n    private updateEntity(e: Entity, i: number, model: ModelDto, markersWithNewLocation: L.Marker[]): void {\n        const marker: L.Marker = this.markersByModelAndId[i][e.id];\n        if (marker && this.isValidCoordinates(e)) {\n            const currentLocation: number[] = e.location.coordinates;\n            if (this.hasLocationBeenUpdated(marker, currentLocation)) {\n                markersWithNewLocation.push(marker);\n            }\n            Object.entries(e).forEach(a => marker[this.entityAttr][a[0]] = a[1]);\n            this.setTooltip(marker, e, model);\n        }\n    }\n\n    private setEntityParams(marker: L.Marker, entity: Entity, model: ModelDto, i: number): void {\n        this.setTooltip(marker, entity, model);\n        this.setPopup(marker, entity, model);\n        marker[this.entityAttr] = entity;\n        this.markersByModelAndId[i][entity.id] = marker;\n        this.layerGroups[model.type].addLayer(marker);\n    }\n\n    private storeMinMaxLocation(lat: number, lon: number): void {\n        this.minLat = this.minLat > lat ? lat : this.minLat;\n        this.minLon = this.minLon > lon ? lon : this.minLon;\n        this.maxLat = this.maxLat < lat ? lat : this.maxLat;\n        this.maxLon = this.maxLon < lon ? lon : this.maxLon;\n    }\n\n    private hasLocationBeenUpdated(marker: L.Marker, currentLocation: number[]): boolean {\n        const currentLatLng: L.LatLng = marker.getLatLng();\n        const currentLat: number = currentLatLng.lat;\n        const currentLng: number = currentLatLng.lng;\n\n        const newLatLng: number[] = currentLocation.slice().reverse();\n        const newLat: number = newLatLng[0];\n        const newLng: number = newLatLng[1];\n\n        return currentLat !== newLat || currentLng !== newLng;\n    }\n\n    /*****************************************************************************\n     Marker event functions\n    *****************************************************************************/\n\n    private setMarkerEvents(marker: L.Marker, p: L.Popup, pRef: ComponentRef<PopupComponent>, entity: Entity, model: ModelDto): void {\n\n        marker.on('click', () => {\n            marker.isPopupOpen() ? this.closePopup(marker) : this.openPopup(marker, p, pRef, entity, model);\n        });\n\n        marker.on('popupopen', () => {\n            marker.closeTooltip();\n        });\n\n        marker.on('popupclose', () => {\n            this.openTooltip(marker);\n            marker.unbindPopup();\n        });\n\n    }\n\n    /*****************************************************************************\n     Popup functions\n    *****************************************************************************/\n\n    private setPopup(marker: L.Marker, entity: Entity, model: ModelDto): void {\n        const popup: L.Popup = L.popup();\n        const popupComponentRef: ComponentRef<PopupComponent> = this.popupService.createPopupComponent(entity, model);\n        popupComponentRef.instance.clickDebug.pipe(takeUntil(this.destroy$)).subscribe(() => this.onClickDebug(model, entity, marker));\n        popup.setContent(popupComponentRef.location.nativeElement);\n        this.setMarkerEvents(marker, popup, popupComponentRef, entity, model);\n    }\n\n    private openPopup(marker: L.Marker, p: L.Popup, pRef: ComponentRef<PopupComponent>, entity: Entity, model: ModelDto): void {\n        this.mapDashBoardService.getEntityForPopup(model, entity).pipe(takeUntil(this.destroy$)).subscribe(\n            data => {\n                const updatedEntity: Entity = data[0];\n                pRef.instance.updatePopup(updatedEntity, model);\n                pRef.changeDetectorRef.detectChanges();\n                pRef.instance.refreshScroll();\n                this.setTooltip(marker, updatedEntity, model);\n                marker.bindPopup(p);\n                marker.openPopup();\n            },\n            err => {\n                this.onLoadDataFail();\n            },\n        );\n    }\n\n    private closePopup(marker: L.Marker): void {\n        marker.closePopup();\n        marker.unbindPopup();\n    }\n\n    /*****************************************************************************\n     Tooltip functions\n    *****************************************************************************/\n\n    private setTooltip(marker: L.Marker, entity: Entity, model: ModelDto, fromDebug?: boolean): void {\n        const tooltipContent: string = this.getTooltipContent(entity, model, fromDebug);\n\n        if (tooltipContent) {\n            if (!marker.getTooltip()) {\n                marker.bindTooltip(tooltipContent, {\n                    offset: new L.Point(0, 5),\n                    direction: 'top',\n                    permanent: true,\n                    opacity: 0.9,\n                });\n            } else {\n                marker.setTooltipContent(tooltipContent);\n            }\n        }\n    }\n\n    private openTooltip(marker: L.Marker): void {\n        if (this.favChecked) {\n            if (marker.getTooltip()) {\n                const elements: NodeList = this.elem.nativeElement.querySelectorAll('.leaflet-tooltip-pane');\n                elements.forEach((e: HTMLElement) => e.style.display = 'block');\n                marker.openTooltip();\n            }\n        }\n    }\n\n    private getTooltipContent(entity: Entity, model: ModelDto, fromDebug?: boolean): string {\n        return model.favAttr && entity[model.favAttr] && (!fromDebug || (fromDebug && entity[model.favAttr].value)) ?\n            ('<span>' + this.truncateTooltipContent(fromDebug ? entity[model.favAttr].value : entity[model.favAttr]) + '</span>') :\n            undefined;\n    }\n\n    private truncateTooltipContent(content: any): string {\n        const str: string = typeof content === 'string' ? content : JSON.stringify(content);\n        return Utils.truncateString(str, this.tooltipMaxChars);\n    }\n\n    private closeTooltipsIfNeeded(): void {\n        const markers: L.Layer[] = this.markerClusterGroup.getLayers();\n        markers.forEach(m => {\n            if (!this.favChecked) { (m as L.Marker).closeTooltip(); }\n        });\n    }\n\n    /*****************************************************************************\n     Main/favourite attributes functions\n    *****************************************************************************/\n\n    private storeFavAttrs(models: ModelDto[]): void {\n        this.favAttrs = models.filter(m => m.favAttr).map(m => ({ entity: m.type, favAttr: m.favAttr }));\n    }\n\n    /*****************************************************************************\n     Debug entity functions\n    *****************************************************************************/\n\n    private onClickDebug(model: ModelDto, entity: Entity, marker: L.Marker): void {\n        this.mapDashBoardService.getEntity(model, entity).pipe(takeUntil(this.destroy$)).subscribe(\n            data => {\n                if (data.length > 0) {\n                    this.onClickDebugSuccess(data[0], marker, model);\n                } else {\n                    this.onLoadDataFail();\n                }\n            },\n            err => {\n                this.onLoadDataFail();\n            },\n        );\n    }\n\n    private onClickDebugSuccess(data: Entity, marker: L.Marker, model: ModelDto): void {\n        marker.closePopup();\n        this.displayDebugHeader = data.id;\n        this.displayDebugContent = data;\n        this.displayDebug = true;\n        this.setTooltip(marker, data, model, true);\n    }\n\n}\n"]}